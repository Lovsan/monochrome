# monochrome
A flexible Discord bot core.
Node 8.9.4 recommended.

In order to get up and running as quickly as possible, consider cloning the [monochrome demo](https://github.com/mistval/monochrome-demo) and customizing it to fit your needs. By doing this, you do not need to create configuration files, command directories, etc from scratch.

## Key features
<ol>
<li>Command framework</li>
<li>Settings framework</li>
<li>Auto-generated help command</li>
<li>Navigations (see below)</li>
<li>Arbitrary message hooks</li>
<li>User deletion of messages</li>
<li>Detailed logging</li>
<li>Good test coverage</li>
</ol>

## Basics
### Installation
```
npm install --save --no-optional monochrome-bot
```
### Usage
```js
let monochrome = require('monochrome-bot');

let configFilePath = __dirname + '/config.json';
let commandsDirectoryPath = __dirname + '/commands';
let messageProcessorsDirectoryPath = __dirname + '/message_processors';
let settingsFilePath = __dirname + '/server_settings.json';
let logsDirectoryPath = __dirname + '/logs';
let onShutdown = () => {};

let bot = new monochrome(
  configFilePath,
  commandsDirectoryPath,
  messageProcessorsDirectoryPath,
  settingsFilePath,
  logsDirectoryPath,
  onShutdown);
bot.connect();
```
The arguments to the monochrome constructor are described below.
### Configuration
monochrome requires a path to a configuration js file. That configuration file should look like this (from the monochrome demo):
```js
module.exports = {
  "botToken": "", // Your bot's token from https://discordapp.com/developers/applications/me
  "botAdminIds": [""], // An array of user IDs for the bot admins (you can use Discord's developer mode to find any user's ID).
  "serverSettingsCommandAliases": ["]settings", "]s"], // The aliases for the built-in settings command (discussed more later). If you don't want a settings command, this should be an empty array.
  "discordBotsDotOrgAPIKey": "", // If you have an API key from discordbots.org, insert it here and stats will be periodically sent.
  "botsDotDiscordDotPwAPIKey": "", // If you have an API key from bots.discord.pw, insert it here and stats will be periodically sent.
  "logsDirectory": "./logs", // The directory to write logs to (can be an empty string). Logs are also written to the console.
  "autoGeneratedHelpCommandAliases": ["bot!help", "bot!h"], // The aliases for the built-in help command. If you don't want a help command, this should be an empty array.
  "colorForAutoGeneratedHelpEmbeds": 2522111, // The built-in help command's advanced help uses embeds. This field controls the embed color.
  "commandsToGenerateHelpFor": [ // This should be an array of commands that you want to have help generated for, in the order that you want them to appear in the help.
    "bot!ping",
    "bot!addquote",
    "bot!getquote",
    "bot!navigation",
    "bot!countdown",
    "bot!about",
    "}setavatar",
    "}broadcast",
    "}delete",
    "}dumpheap",
    "}eval",
    "}servers",
    "]settings"
  ],
  "useANSIColorsInLogFiles": true,  // Whether ANSI color codes should be used in the log file or not. If you're going to be cat'ing log files in a console, you probably want this to be true. If you're going to be opening logs in notepad, you may want to set this to false.
  "serverAdminRoleName": "monochrome", // Users with a role with this name will be considered server admins able to run server admin commands.
  "genericErrorMessage": "Oh no, that command had an error! Please tell my owner to check the logs!", // If a command errors and that error escapes into core code, this message will be sent to the channel. If you don't want a generic error message, this can be an empty string.
  "genericDMReply": "Hi <user>, bot!help to see my commands!", // The bot will reply with this when DM'd, if the DM doesn't contain a command. <user> is replaced with the user's name.
  "genericMentionReply": "Hi <@user>, say bot!help to see my commands!", // The bot will reply like this when mentioned. <@user> mentions the user.
  "inviteLinkDmReply": "Click http://123.xyz to invite me to your server!", // Sometimes people will DM the bot a server invite link to try to add it to a server. When this happens, the bot will reply with this message.
  "missingPermissionsErrorMessage": "I don't have permission to reply to that command in this channel (maybe I don't have permission to upload files, embed links, etc)", // If the bot cannot create a message due to missing permissions, and that error escapes into core code (which it generally should, more on that under Best Practices) then this message will be sent to the channel.
  "statusRotation": [ // An array of statuses to rotate through.
    "bot!help for commands!",
    "eating chicken",
    "buying games on steam"
  ],
  "statusRotationIntervalInSeconds": 600, // How often to change status.
  "colorForSettingsSystemEmbeds": 2522111, // The built-in settings command uses embeds. That field controls the color of those embeds.
  "settingsCategorySeparator": "/" // Settings are hierarchical. If the value of this field is "/", then a setting called "enabled" under a category called "lazer_cannon" will be referred to as "lazer_cannon/enabled"
}

```
### Commands
monochrome requires a path to a directory where you put your command files. A command file should look like this (though most fields may be omitted):
```js
module.exports = {
  commandAliases: ['bot!hello', 'bot!hi'], // Aliases for the command
  commandAliasesForHelp: ['bot!hello'], // The aliases that will appear in the auto-generated help. This is useful if you want the bot to respond to a certain alias, but you want to deprecate that alias or you would prefer for users to use other aliases. If your command provides this array, then only the aliases in this array will appear in the help.
  shortDescription: "You say bot!hello, I say Hello World!", // A one, maybe two sentence description that will appear in the help.
  longDescription: "You say bot!hello, I say Hello World! It's my most amazing feature", // A longer description that will appear in the advanced help for the command. If not provided, shortDescription will be used as the longDescription.
  usageExample: "bot!hello", // An example of how the user should invoke the command. If the command doesn't take any arguments (like this one), then there is probably no need to provide this.
  uniqueId: 'hello4859', // Can be anything, as long as it's unique, and you shouldn't change it.
  requiredSettings: ['hello/hello_text'], // What settings this command requires. See the Settings section below for more details, or the monochrome/commands/countdown.js command for an example.
  serverAdminOnly: false, // If true, only server admins can use this command. False by default.
  botAdminOnly: false, // If true, only bot admins (whose ids are listed in monochrome/config.js) can use this command. False by default.
  onlyInServer: false, // If true, this command will not be allowed in DMs. False by default.
  canBeChannelRestricted: true, // If true, then server admins can control which channels this command is allowed to execute in. If false, they cannot. True by default.
  attachIsServerAdmin: false, // If true, the msg object will have an authorIsServerAdmin property you can use to determine if the user is a server admin. False by default due to small but non-negligible performance cost.
  action(bot, msg, suffix, settings, extension) { // Your code here! The bot argument is Eris.Client and the msg argument is Eris.Message. See the Eris help for info about them: https://abal.moe/Eris/docs. The suffix is the arguments for the command (for example if the user says "bot!hello 123" then the suffix is "123"). The settings argument is an object containing the required settings for the command. See the monochrome/commands/countdown.js command for an example. The extension argument is discussed below.
    return bot.createMessage(msg.channel.id, 'Hello World!');
  },
  canHandleExtension(extension) { // Return whether the command can handle a given extension (see below)
    return false;
  }
};
```
### Message processors
monochrome requires a path to a directory where you put your message processor files. A message processor is an arbitrary hook that can process any message sent to the bot, regardless of whether or not it starts with a command. A message processor file should look like this:
```js
module.exports = {
  name: 'Palindrome',
  action: (bot, msg) => {
    let text = msg.content;
    let textBackwards = text.split('').reverse().join('');
    if (text === textBackwards) {
      bot.createMessage(msg.channel.id, 'That\'s a palindrome!');
      return true;
    } else {
      return false;
    }
  }
};
```
### Settings
monochrome can be provided a path to a js file where you define settings for server admins to configure. Alternatively, that argument to the bot constructor may be omitted. The settings file should look like this:
```js
module.exports = [
  {
    "type": "CATEGORY", // "CATEGORY" for a group of settings, "SETTING" for a setting.
    "userFacingName": "fun", // This is the name of the category. The user will see it if they use the settings command.
    "children": // A category's children can be either other CATEGORYs or SETTINGs, but not both.
    [
      {
        "type": "SETTING",
        "userFacingName": "countdown_start", // This is the name of the setting. The user will see it if they use the settings command. Its full path is fun/countdown_start.
        "description": "This setting controls what number I'll count down from when you use the bot!countdown command.",
        "valueType": "INTEGER", // Can be INTEGER, FLOAT, STRING, or BOOLEAN
        "defaultDatabaseFacingValue": 10,
        "allowedDatabaseFacingValues": "Range(1, 10)" // This can be a range as shown here, or an array of discrete values, or it can be undefined.
      }
    ]
  }
];
```
This adds a settings category called 'fun' with a setting called 'countdown_start'. [Here is how a server admin would view and set this setting.](https://github.com/mistval/monochrome/blob/master/settings_example.png)

And here is how a countdown command can require and use the value of that setting:
```js
module.exports = {
  commandAliases: ['bot!countdown'],
  botAdminOnly: false,
  uniqueId: 'countdown29490',
  requiredSettings: ['fun/countdown_start'],
  shortDescription: 'Start a countdown.',
  action(bot, msg, suffix, settings) {
    let countdownStart = settings['fun/countdown_start'];
    for (let i = countdownStart; i >= 0; --i) {
      setTimeout(() => {
        msg.channel.createMessage(i.toString());
      }, (countdownStart - i) * 2000);
    }
  },
};
```
In the image, you may have noticed that there is also an enabled_commands settings category. This category is automatically generated by monochrome and lets server admins control where commands can and cannot be used.
### onShutdown
monochrome can be passed an onShutdown callback that will be called when you execute the }shutdown command (further discussed below). You can use that callback to do necessary cleanup before shutting down. If you return a promise from the callback, monochrome will wait until the promise resolves or rejects before shutting down.

## Advanced
### Command extensions
Command extensions are an alternative to command arguments and command aliases, and may be more convenient in some cases.

As an example, consider a bot!translate command. If someone says "bot!translate German is fun", do they want to translate "German is fun" or do they want to translate "is fun" into German?

You might consider having separate commands like bot!translategerman, bot!translatefrench, bot!translateitalian, etc. Or you can use command extensions and have all of those invoke one command. This is especially useful if you do not know or do not want to list all of the languages that your translation API provides.

Here is how command extensions can be used in this scenario to respond to both bot!translategerman and bot!translatefrench:
```js
module.exports = {
  commandAliases: ['bot!translate'],
  uniqueId: 'hello4859',
  action(bot, msg, suffix, settings, extension) {
    if (extension === 'french') {
      return msg.channel.createMessage(translateFrench(suffix))
    } else if (extension === 'german') {
      return msg.channel.createMessage(translateGerman(suffix))
    }
  },
  canHandleExtension(extension) {
    return extension === 'french' || extension === 'german';
  }
};
```
### Navigations
A navigation is a message that the bot edits in response to reactions, allowing a user to browse through pages of information.

![Navigation gif](https://github.com/mistval/monochrome/blob/master/nav.gif "Navigation gif")

See [this demo command](https://github.com/mistval/monochrome-demo/blob/master/commands/navigation.js) for the code behind the above example.
### Dynamic reloading
In general, when you change bot code, it is safest to stop and restart the bot. But if your bot has volatile data that you don't want to lose, or if you want absolutely zero downtime, monochrome supports dynamic reloading of code via the }reload command. You can add, remove, or modify commands and any other code of yours on the fly, without stopping the bot.

In order to support this, you must do one thing. In your commands, use the reload module to import your modules, instead of ```require```. Here is an example:

```js
const reload = require('require-reload')(require);
const textRenderer = reload('./../utils/render_text.js');
```

You should only ```reload``` your own code. monochrome-bot and other npm modules should be imported normally with ```require```.

```Reload``` does not play nicely with mutable static data (for example a singleton that has state). For best results when using the }reload command, avoid mutable static data in your code. If you must have mutable static data, use ```require``` instead of ```reload``` to import files that contain mutable static data. Consider separating mutable static data and program logic into separate files, so that you can ```reload``` program logic and ```require``` static data.

The only field in your configuration file that is guaranteed to be reloaded by the }reload command is commandsToGenerateHelpFor. Most other fields will probably be reloaded as well, but this is not guaranteed.
### Shutdown
To cleanly shut down the bot, you can use the }shutdown command. If you are using a process manager (such as [forever](https://www.npmjs.com/package/forever)) to automatically restart the process, then the }shutdown command can be used to restart the process.
### User-deletable responses
If a user invokes a command and then deletes their message that invoked the command, you may wish for the bot to delete its response to the command. monochrome extends Eris to make this easy for you. Simply pass the user's message as the third argument into channel's createMessage method. Here is an example from the monochrome demo of a command that does this:
```js
module.exports = {
  commandAliases: ['bot!ping', 'bot!p'],
  canBeChannelRestricted: true,
  uniqueId: 'ping5959045',
  serverAdminOnly: false,
  shortDescription: 'You say bot!ping, I say pong.',
  action(bot, msg, suffix) {
    return msg.channel.createMessage('Pong!', null, msg);
  },
};
```
Because you passed msg into the createMessage method, now if msg gets deleted, the message created by createMessage will also be deleted. In addition, if the author of msg reacts to the bot's message with ❌, the bot will delete it.
### Persistence
Persistence powered by node-persist is built in and can be accessed with ```require('monochrome-bot').persistence```

For examples of using persistence, see the following commands in the monochrome demo:  
[Add quote command](https://github.com/mistval/monochrome-demo/blob/master/commands/addquote.js)  
[Get quote command](https://github.com/mistval/monochrome-demo/blob/master/commands/getrandomquote.js)  

The edit functions are atomic. That is, you don't need to be concerned about two different actors reading the same data, making different edits to it, and overwriting each other.

### Logging
The Logger singleton can be used for logging.
```js
const logger = require('monochrome-bot').logger;

logger.logSuccess('TITLE', 'message');
logger.logFailure('TITLE', 'message', errorObjectIfThereIsOne);
```
### Documentation
JSDoc can be used to generate documentation for the core classes.
```
npm install -g jsdoc
sh node_modules/monochrome-bot/generate_documentation.sh
```
And then open node_modules/monochrome-bot/documentation/index.html. However the documentation is not currently very useful.
## Best Practices And What to Return to Core
This section mainly discusses what the action() function of your commands and message processors should return when invoked.

The simplest thing you can do is return nothing from commands. From message processors, you can return true if the message processor agrees to handle the message, false if not. 

However, doing this does not take full advantage of monochrome's built-in error handling and logging.
### Returning promises
It is best for a command to return a promise, and for a message processor to return a promise if it agrees to handle the message, or false if it does not.

When your command returns a promise, the command manager will wait for that promise to resolve before logging success. If the promise rejects, the command manager will log that as a failure, along with a stack trace, and will also send the genericErrorMessage from your config.json to the channel (unless the error is a PublicError, which is discussed below).

TIP: Most Eris methods return promises, for example ```msg.channel.createMessage('hi')``` returns a promise. Therefore, when you call msg.channel.createMessage() to send the result of the command to the channel, you should return: ```return msg.channel.createMessage('hi')```. By doing this, you ensure that errors such as over-sized messages and timeouts are caught and logged.
### Throwing
If your command fails in an irrecoverable way (even if it's an expected failure), you should throw and allow the bot core to handle it (by logging it and sending a failure message).
### Throwing PublicError
PublicError is a class available from monochrome.

For expected failures, you generally should throw a PublicError.

Here is an example of throwing PublicError:
```js
let PublicError = require('monochrome-bot').PublicError;
...
}).catch(err => {
  throw new PublicError('Sorry, Jisho is not responding. Please try again later.', false, 'Error fetching from Jisho', err);
});
```
When the command manager catches your PublicError, it will send the public message to the channel:

![PublicError channel message](https://github.com/mistval/monochrome/blob/master/public_error_message.png)

It will also log the error with the error reason and the stack trace:

![PublicError log message](https://github.com/mistval/monochrome/blob/master/public_error_log.png)

PublicError should be constructed via one of its factory methods:

```js
PublicError.createWithCustomPublicMessage(publicMessage {String}, deleteAutomatically {Boolean}, logDescription {String}, internalErr {Error});

PublicError.createWithGenericPublicMessage(deleteAutomatically {Boolean}, logDescription {String}, internalErr {Error});

PublicError.createWithNoPublicMessage(logDescription {String}, internalErr {Error});
```

publicMessage gets sent to the user. If deleteAutomatically is true, that message gets deleted after a short amount of time. The logDescription is a brief description of the error for logging (can be undefined). internalErr is an Error object to log a stack trace for (can be undefined).

Note that in the case of a PublicError being thrown in a message processor, the publicMessage will be ignored and no message will be sent to the user. This is to protect against the possibility of your bot erroring and publically broadcasting an error for every single message sent in a server. If you are certain that you want to circumvent that behavior, you can catch the PublicError yourself, broadcast the publicMessage, and rethrow the error.

## Sample bot
Add my bot [Kotoba](https://discordapp.com/oauth2/authorize?client_id=251239170058616833&scope=bot) to your server to see an example of a bot running on monochrome.
## Help
[Support](https://discord.gg/f4Gkqku)

For bug reports or feature requests please open an issue on the Github repo.